# 非同期関数とピン留め

Rustの非同期関数は、内部状態をもつ状態遷移マシンになり、自己参照をもつ構造体になるためピン留め（Pinning）が必要になる。
この概念を理解するためには、次の3つを理解する必要がある。

- 非同期関数と状態遷移マシン（State Machine）
- 状態遷移マシンとしての自己参照
- ピン留め（Pinning）の役割

## 非同期関数と状態マシン

`async fn`はコンパイル時に特殊な構造体に変換される。
この構造体は、`Future`トレイトを実装しており、その`poll`メソッドが呼ばれるたびに処理を進める。

非同期関数の処理は複数の段階に分割される。
それぞれの段階の間に`await`ポイントが存在する。
`await`に到達すると、非同期関数は一時停止して、制御を呼び出し元に返す。
次に`poll`が呼び出されたときに、前回停止した場所から処理を再開する。

上記仕組みは**状態遷移マシン**そのものである。

- 状態（State）: 非同期関数の実行中に存在するローカル変数、`await`の後に実行する処理の場所（どの`await`まで進んだか）などを、`Future`構造体のフィールドに持つ
- 遷移（Transition）: `poll`メソッドが呼び出されると、状態は次の`await`ポイントまで進む
- イベント: `poll`の呼び出し

```rust
async fn my_async_fn() {
    let a = 1;
    let b = some_other_async_op().await; // await 1
    let c = a + b;
    yet_another_async_op(c).await; // await 2
}
```

上記関数は、コンパイル時に次のような擬似的な状態遷移マシンに変換される。

```rust
enum MyAsyncFnState {
    Start {
        a: i32,
    },
    AwaitingSomeOtherOp {
        a: i32,
        future_of_some_other_op: SomeOtherAsyncOpFuture,
    },
    AwaitingYetAnotherOp {
        c: i32,
        future_of_yet_another_op: YetAnotherAsyncOpFuture,
    },
    End,
}

// 実際のFutureは、この列挙型を内部に持った構造体
struct MyAsyncFnFuture {
    state: MyAsyncFnState,
}
```

`MyAsyncFnFuture`構造体の`poll`メソッドが呼ばれるたびに、構造体の`state`フィールドが更更新されて、次の状態に遷移する。

## 状態マシンとしての自己参照

問題は、非同期関数のローカル変数が、別のローカル変数への参照を含む場合、`await`の前後で参照元の変数が生き残っている必要があることである。

```rust
async fn my_async_fn() {
    let my_struct = MyStruct::new();
    let my_ref = &my_struct.some_field;

    // awaitの前後で`my_struct`と`my_ref`の両方が存在し続ける必要がある
    some_async_op(my_ref).await;

    // ...
}
```

上記コードは、コンパイル時に以下のような`Future`構造体に変換される。

- `my_async_fn`は、上記のような`Future`構造体に変換される。
- この`Future`構造体は、`my_struct`と`my_ref`という2つのフィールドを持つ。
- `my_ref`は、`my_struct`という**同じ構造体への別フィールドへの参照**である。
- これは、**自己参照（Self-referential）**をもつ構造体となる。

構造体は、メモリ上で移動（ムーブ）する可能性があり、移動した場合`my_ref`が有効なポインタを指し示さなくなるため、通常、自己参照構造体を作成できない。

- `my_async_fn`の`Future`インスタンスがスタックからヒープへ、あるいは別のスタックフレームへ移動されたとする。
- このとき、`my_struct`のメモリ位置は新しい場所に移動する。
- しかし、`my_ref`は依然として古いメモリ位置を指したままになっている。
- この**ダングリングポインタ（無効なポインタ）**は、メモリ安全性違反を引き起こす。

この自己参照の問題を解決するために、**ピン留め（Pinning）**が必要になる。

## ピン留め（Pinning）の役割

ピン留めとは、あるインスタンスがメモリ上で**ムーブされない（動かない）ことを保証**するための仕組みである。
`std::pin::Pin`ラッパーを使用することで、構造体のインスタンスがメモリ上で固定されることにより、その構造体が持つ参照の参照先のデータが固定されて、他の場所に移動しなくなる。

`async`の世界では、`Future`は`Pin<&mut T>`として、`poll`メソッドに呼び出される。

```rust
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
```

上記`Pin<&mut Self>`は、`Future`構造体（つまり、内部の状態遷移マシン）が`poll`メソッドを実行している間、メモリ上で移動しないことをRustコンパイラに伝える。

ピン留めによって、次の通り自己参照`Future`構造体の問題が解決する。

- `Future`インスタンスがピン留めされると、そのメモリ位置は固定される。
- `Future`内の自己参照、例えば`my_ref`は、`my_struct`の**固定された有効なメモリ位置を安全に指し続ける**。
- これで、ダングリングポインタの問題を回避し、`Future`を安全に実行できる。

## まとめ

- 非同期関数は、コンパイル時にローカル変数や`await`の場所を保持する状態遷移マシン（`Future`）に変換される。
- この`Future`は、`await`を挟んでローカル変数が互いに参照し合う場合、自己参照を持つ構造体になる。
- 通常のムーブ可能な構造体では、自己参照がメモリ安全性の問題を引き起こす。
- ピン留めは、`Future`がメモリ上で移動しないことを保証することで、自己参照を安全に維持できるようにする仕組みである。
- これにより、Rustの非同期ランタイムは、安全に非同期関数を実行することができる。

このように、「非同期関数は内部状態を持つ状態遷移マシンになり、自己参照を持つ構造体になるためピン留めが必要になる」という説明は、Rustの非同期処理の核心的な設計思想を簡潔かつ正確に表現している。
