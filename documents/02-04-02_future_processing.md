# 2.4.2 ヒューチャー処理の様子

## ステップ1: フューチャの作成

次の通りフューチャーを作成する。

- 非同期関数を作成
- `Future`トレイトを実装

非同期関数を呼び出すとフューチャーが返されるが、この時点でフューチャーは全く処理をしておらず、フューチャーに対して`await`もされていない。

## ステップ2: フューチャーをエグゼキューターに登録

`Future`は直接「自分で勝手に進む」ことはできない。
エグゼキューターに登録することで、エグゼキューターがその`Future`をタスクとして管理し、必要に応じて`poll`メソッドを呼び出す。
多くの非同期ランタイム（`tokio`, `async-std`など）では`tokio::spawn`のような関数でタスクを生成して実行を開始する

> 書籍では、「タスクの起動」のステップであり、「タスクを`await`することで、タスクを起動する。」と記述されている。
> しかし、これは曖昧なため、このステップを「フューチャーを起動」として、フューチャーの起動について次に示す。

## ステップ3: タスクのポーリング

エグゼキューターは登録されたタスクに対して`Future::poll`を呼び出す。
`Future::poll`メソッドの戻り値は次のいずれかである。

- `Poll::Ready(T)`: フューチャーの処理は終了
- `Poll::Pending`: フューチャーの処理は終了していない

`Future::poll`メソッドが`Poll::Pending`を返す場合、その`Future::poll`メソッドの呼び出しで引数として受け取ったコンテクストからウェイカーを取り出し、ウェイカーを介してエグゼキューターに次の`Future::poll`メソッドの呼び出しを登録する。
この`Future::poll`メソッドの呼び出しを登録することで、最終的に`Future`の処理が完了する。
