# 2.6 まとめ

- 非同期処理は、決定的な順番で動作しない
- 非同期処理の順番を保証するためには、フューチャーを1つだけ作成して、次のようにする
  - フューチャーにキューのようなデータ構造を持たせる
  - そのキューを`Mutex`でラップする
- フューチャーはポーリングされることで処理が進む
- フューチャーをポーリングするのはエクゼキューター
- フューチャーはポーリングされると次を返す
  - `Poll::Pending`: フューチャーの処理が終了していない
  - `Poll::Ready(T)`: フューチャーの処理が終了している（`Output = T`を`Poll::Ready`でラップ）
- フューチャーが`Poll::Pending`を返した場合、エグゼキューターは再度フューチャーをポーリングしなければならない
- フューチャーが`Poll::Pending`を返したとき、エグゼキューターがすぐにフューチャーをポーリングした場合、フューチャの処理が終了していない可能性が高く、再度`Poll::Pending`を受け取りことになり、CPUを浪費
- ウェイカーは、フューチャーの処理が終了して、結果がえられた後に、エグゼキューターが再度ポーリングするようにする
- `Poll::Pending`を返したフューチャーは、ウェイカーが呼び出されるまで、エグゼキューターにポーリングされない
- ウェイカーを呼び出すのは、ネットワーク通信の場合ソケットを監視する`epoll`や`select`などのシステムコールを呼び出す専用スレッドなどになる
- この場合、エグゼキューターはフューチャーをポーリングして、フューチャーはその専用スレッドをポーリングするなど、多段になる
- 非同期関数は状態マシンに変換される
- 非同期関数が複数の`await`ポイントを持っている場合、`await`ポイントでエグゼキューターが他のフューチャーにポーリングするため、途中までの状態を保持して、次にポーリングされたときに`await`ポイントの次から実行できるようにする
- 非同期関数が複数の`await`ポイントを持っている場合、状態マシンは多くの状態を保持する必要があり複雑になる
