# Rustの非同期処理

## 用語説明

### フューチャー（Future）

**フューチャー**とは、非同期で将来完了するであろう処理を抽象化したトレイトである。
フューチャーは非同期処理の最小単位であり、`async`キーワードで定義された関数やブロックは、コンパイラによって最終的にフューチャーに変換される。
フューチャーは、pollと呼ばれる唯一のメソッドを持っている。

フューチャーは非同期処理を内包しており、その完了を待機するが、他の非同期処理の進行を妨げない。

### pollメソッド

`poll`メソッドは、フューチャーの計算を進める唯一の手段である。
フューチャーが計算を進められる状態であれば処理を進め、そうでなければ進めずに停止する。

`poll`メソッドは、2つの状態を表す`Poll`列挙型のいずれかを返す。

### Poll列挙型

`Poll`列挙型は、`poll`メソッドの戻り値であり、フューチャーの現在の状態を示す。

- `Poll::Ready(T)`: 非同期処理が完了し、その処理結果を表す`T`型の値が準備できたことを示す。
- `Poll::Pending`: 非同期処理が未完了であり、待機中であることを示す。

`poll`メソッドが`Poll::Pending`を返した場合は、現時点で非同期処理を進められないことを意味する。

### コンテクスト（Context）とウェイカー（Waker）

`poll`メソッドが`Poll::Pending`を返した場合、非同期処理を再開するため**にコンテクスト**と**ウェイカー**が使用される。

#### コンテクスト（Context）

`poll`メソッドは、非同期処理の実行に必要な情報を保持する**コンテクスト（Context）**インスタンスを受け取る。
このコンテクストには**ウェイカー**が含まれている。

#### ウェイカー（Waker）

**ウェイカー（Waker）**は、非同期処理が再開可能になったことをエグゼキューターに通知する仕組みである。
ウェイカーには`wake`メソッドがあり、これを呼び出すことでフューチャーが再度`poll`される準備ができたことを知らせる。

具体的には、ネットワーク通信やファイルI/Oなどの非同期処理を行う場合、処理が完了するまで`poll`メソッドは`Poll::Pending`を返す。
このとき、I/Oドライバは内部的にウェイカーを保持し、I/Oが完了した時点でウェイカーの`wake`メソッドを呼び出す。

### タスク（Task）

**タスク（Task）**は、フューチャーを管理する実行単位である。
エグゼキューターはタスクをキューに入れて順番に処理を進める。
1つのタスクは1つのフューチャーに対応する。

### エグゼキュター（Executor）

**エグゼキューター（Executor）**は、フューチャーの処理を進める役割を担う。
フューチャーのpollメソッドを繰り返し呼び出すことで処理を少しずつ進める。

`poll`メソッドが`Poll::Pending`を返した場合、エグゼキューターはそのタスクを一時停止し、別のタスクを処理する。
その後、ウェイカーの`wake`メソッドが呼ばれると、エグゼキューターは対応するタスクを再びキューに入れ、再度`poll`を試みる。

### ランタイム（Runtime）

**ランタイム（Runtime）**は、非同期処理全体の実行環境を提供する。
エグゼキューターだけでなく、I/O処理やタイマーなどの非同期イベントの管理やタスクスケジューリングも行う。
代表的なランタイムには、`tokio`や`async-std`などがある。

## 非同期処理の流れ

Rustの非同期処理は、ポーリングとウェイクアップというシンプルな仕組みに基づく協調的マルチタスクである。
これにより、大量のOSスレッドを作成せずとも効率的かつ安全に非同期処理を実行できる。

1. `async fn`や`async`ブロックで非同期処理が定義されると、フューチャーにコンパイルされる。
2. エグゼキューターは、このフューチャーをタスクとして受け取り、キューに入れる。
3. エグゼキューターは、キューからタスクを取り出し、フューチャーの`poll`メソッドを呼び出す。
4. フューチャーの`poll`メソッドは、処理を一部進め、結果が得られたかどうかを`Poll`列挙型で返す。
5. `poll`が`Poll::Pending`を返した場合、エグゼキューターはタスクを一時停止し、別のタスクに切り替える。このときコンテクスト内のウェイカーが非同期処理を行うドライバに保存される。
6. 非同期処理を行うドライバは、ネットワークI/Oなどの処理が完了すると、保存しておいたWakerのwakeメソッドを呼び出す。
7. wakeが呼ばれると、エグゼキューターはタスクが再開可能になったことを検知し、再びタスクをキューに入れる。
8. エグゼキューターは、再度キューからタスクを取り出してpollを呼び出す。このサイクルはPoll::Ready(T)が返る1. まで繰り返される。
9. pollがPoll::Ready(T)を返すと、フューチャーの処理は完了し、結果であるT型の値を利用できるようになる。

```text
+-----------+       +-------------+        +-------------+
|  Executor |       |   Future    |        | I/O Driver  |
+-----------+       +-------------+        +-------------+
       |                   |                      |
       | poll()            |                      |
       |------------------>|                      |
       |                   |--- I/O 未完了 ------->|
       |                   |<-- Waker を登録 ------|
       |                   |                      |
       |  Poll::Pending    |                      |
       |<------------------|                      |
       |                   |                      |

             ...別のタスクを poll...

       |                   |                      |
       |                   |---- 結果が揃った ------|
       | (I/O 完了通知)     |                      |
       |<------------------| wake()               |
       |                   |                      |
       | poll()            |                      |
       |------------------>|                      |
       |  Poll::Ready(T)   |                      |
       |<------------------|                      |
```
